package com.mattg.viewmodelexample.fragments;

import android.os.Bundle;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProviders;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Toast;

import com.mattg.viewmodelexample.databinding.FragmentTotalsBinding;
import com.mattg.viewmodelexample.utils.AppError;
import com.mattg.viewmodelexample.utils.CurrencyTextWatcher;
import com.mattg.viewmodelexample.utils.CurrencyUtil;
import com.mattg.viewmodelexample.viewModels.MainViewModel;

import org.jetbrains.annotations.NotNull;

import java.text.DecimalFormat;

/**
 * A simple {@link Fragment} subclass.
 * Use the {@link TotalsFragment#newInstance} factory method to
 * create an instance of this fragment.
 * THIS IS AUTO GENERATED BY ANDROID STUDIO, CAN INCLUDE ITS OWN GENERATED VIEW MODEL
 */
public class TotalsFragment extends Fragment {
    private FragmentTotalsBinding binding;
    private DecimalFormat df = new DecimalFormat("##.##");


    // TODO: Rename parameter arguments, choose names that match
    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER
    private static final String ARG_PARAM1 = "param1";
    private static final String ARG_PARAM2 = "param2";
    private MainViewModel fragmentViewModel;

    // TODO: Rename and change types of parameters
    private String mParam1;
    private String mParam2;

    /**
     * Use this factory method to create a new instance of
     * this fragment using the provided parameters.
     *
     * @param param1 Parameter 1.
     * @param param2 Parameter 2.
     * @return A new instance of fragment TotalsFragment.
     */
    // TODO: Rename and change types and number of parameters
    public static TotalsFragment newInstance(String param1, String param2) {
        TotalsFragment fragment = new TotalsFragment();
        Bundle args = new Bundle();
        args.putString(ARG_PARAM1, param1);
        args.putString(ARG_PARAM2, param2);
        fragment.setArguments(args);
        return fragment;
    }

    public TotalsFragment() {
        // Required empty public constructor
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (getArguments() != null) {
            mParam1 = getArguments().getString(ARG_PARAM1);
            mParam2 = getArguments().getString(ARG_PARAM2);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        binding = FragmentTotalsBinding.inflate(inflater, container, false);
        return binding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull @NotNull View view, @Nullable @org.jetbrains.annotations.Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        //get reference to viewModel
        fragmentViewModel = ViewModelProviders.of(requireActivity()).get(MainViewModel.class);
        //meaningful view configuration method names, so that on view created method remains readable
        //and the sequential steps are clear
        observeViewModel();
        setTextWatchers();
        setButtonClickListeners();
    }

    /**
     * Handles assigning click listener functions to all view buttons, could possibly generalize some
     * of these methods to reduce lines but for now, similar view functions inside of a single view
     * function helps keep the most important function of this view class readable.
     */
    private void setButtonClickListeners() {
        binding.btnAddToTotal.setOnClickListener(v -> {
            if(binding.etAdd.getText() != null) {
                Double amount = CurrencyUtil.currencyValue(binding.etAdd.getText().toString().replace("$", ""));
                fragmentViewModel.updateSubtotal(amount, true);
            } else {
                Toast.makeText(getContext(), "Please enter a valid amount", Toast.LENGTH_SHORT).show();
            }
        });
        binding.btnSubtractToTotal.setOnClickListener(v-> {
            if(binding.etSubtract.getText() != null){
                Double amount = CurrencyUtil.currencyValue(binding.etSubtract.getText().toString().replace("$", ""));
                fragmentViewModel.updateSubtotal(amount, false);
            } else {
                Toast.makeText(getContext(), "Please enter a valid amount", Toast.LENGTH_SHORT).show();
            }
        });
        binding.btnSetDiscountAmount.setOnClickListener(v -> {
            if(binding.etDiscount.getText() != null){
                Double amount = CurrencyUtil.currencyValue(binding.etDiscount.getText().toString().replace("$", ""));
                fragmentViewModel.updateDiscount(amount);
            } else {
                Toast.makeText(getContext(), "Please enter a discount amount", Toast.LENGTH_SHORT).show();
            }
        });
    }

    /**
     * Ensures that all edit text in this view have their text being watched (edited to display as
     * appropriate currency value).  This textwatcher is a separate class, and we could add variants
     * of that class elsewhere, and set them here on any future edit text addtions
     */
    private void setTextWatchers() {
        binding.etDiscount.addTextChangedListener(new CurrencyTextWatcher(binding.etDiscount));
        binding.etTax.addTextChangedListener(new CurrencyTextWatcher(binding.etTax));
        binding.etSubtract.addTextChangedListener(new CurrencyTextWatcher(binding.etSubtract));
        binding.etAdd.addTextChangedListener(new CurrencyTextWatcher(binding.etAdd));
    }

    /**
     * This method handles the observation of viewmodel livedata values.  The view should not be concerned
     * with calculation of data, manipulation of data, etc.  The view class is concerned with providing
     * layout inflation, and the display of data to that layout.  It also must handle click events and
     * other user input.  This is enough work for a view isn't it?  We can pass the hard work of data
     * manipulation, IO operations, network calls and their results/errors, and database handling off to
     * other classes and simply observe the results here.
     */
    private void observeViewModel() {
        //this is a fairly standard way to observe a viewmodels live data value
        //this can be applied to any livedata wrapped value, in any class that has
        //reference to a viewmodel providing livedata values for observation
        fragmentViewModel.getCurrentSubTotal().observe(getViewLifecycleOwner(), subtotal -> {
            if(subtotal != null) {
                binding.txtSubTotal.setText(df.format(subtotal));
            } else {
                binding.txtSubTotal.setText(AppError.NO_VALUE.getLabel());
            }
        });
        fragmentViewModel.getCurrentTax().observe(getViewLifecycleOwner(), taxAmount -> {
            if(taxAmount != null) {
                binding.txtTax.setText(df.format(taxAmount));
            } else {
                binding.txtTax.setText(AppError.NO_VALUE.getLabel());
            }
        });
        fragmentViewModel.getCurrentTotal().observe(getViewLifecycleOwner(), total -> {
            if(total != null) {
                binding.txtTotal.setText(df.format(total));
            } else {
                binding.txtTotal.setText(AppError.NO_VALUE.getLabel());
            }
        });
        fragmentViewModel.getCurrentDiscountsTotal().observe(getViewLifecycleOwner(), discountsTotals -> {
            binding.txtDiscounts.setText(df.format(discountsTotals));
            if (discountsTotals == null) {
                binding.txtDiscounts.setText(df.format(discountsTotals));
            } else {
                binding.txtDiscounts.setText(AppError.NO_VALUE.getLabel());
            }

        });
    }


    @Override
    public void onDestroy() {
        super.onDestroy();
        binding = null;
    }
}